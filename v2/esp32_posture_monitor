#include <Wire.h>
#include <math.h>
#include <WiFi.h>
#include <WebServer.h>

// WiFi credentials
const char* ssid = "Rogers116";       // Replace with your WiFi SSID
const char* password = "6478988917";   // Replace with your WiFi password

// Create web server on port 80
WebServer server(80);

// MPU6050 I2C address
#define MPU6050_ADDR 0x68

// Registers
#define PWR_MGMT_1 0x6B
#define ACCEL_XOUT_H 0x3B

// Buzzer pin
#define BUZZER_PIN 18  // Change to the pin connected to your buzzer
#define BUTTON_PIN 23  // Define GPIO23 as the button input

// Variables to store sensor data
int16_t ax, ay, az;

// Angles (in degrees)
float roll = 0.0;
float pitch = 0.0;
float initial_roll = 0.0;
float initial_pitch = 0.0;

// Threshold for change in angle
float angle_threshold = 20.0;

// Flag for manual buzzer control
bool manual_buzzer_override = false;
bool manual_buzzer_state = false;

void setup() {
  // Start serial communication
  Serial.begin(115200);
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  Serial.println("Connecting to WiFi...");
  
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  
  // Initialize web server routes - only the minimal endpoints
  server.on("/buzzer-on", handleBuzzerOn);
  server.on("/buzzer-off", handleBuzzerOff);
  
  // Start server
  server.begin();
  Serial.println("HTTP server started");
  
  // Initialize I2C communication
  Wire.begin();
  
  // Wake up the MPU6050
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(PWR_MGMT_1); // Wake up MPU6050
  Wire.write(0); // Set to 0 to wake up the device
  Wire.endTransmission(true);
  
  // Initialize the buzzer pin
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);  // Use internal pull-up resistor for the button

  // Wait for a brief moment to ensure the MPU6050 is ready
  delay(100);

  // Read the initial accelerometer data to calculate the initial angles
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(ACCEL_XOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050_ADDR, 6, true); // Request 6 bytes of data
  
  ax = (Wire.read() << 8) | Wire.read();
  ay = (Wire.read() << 8) | Wire.read();
  az = (Wire.read() << 8) | Wire.read();
  
  // Convert accelerometer data to 'g' (assuming the sensor is set to ±2g)
  float ax_g = ax / 16384.0;
  float ay_g = ay / 16384.0;
  float az_g = az / 16384.0;

  // Calculate the initial roll and pitch angles (starting angles)
  initial_roll = atan2(ay_g, az_g) * 180.0 / M_PI;
  initial_pitch = atan2(-ax_g, sqrt(ay_g * ay_g + az_g * az_g)) * 180.0 / M_PI;

  // Print the initial angles to the serial monitor
  Serial.print("Initial Roll: ");
  Serial.print(initial_roll);
  Serial.print("\tInitial Pitch: ");
  Serial.println(initial_pitch);
}

void loop() {
  // Handle client requests
  server.handleClient();
  
  // Check if the button is pressed (active LOW)
  if (digitalRead(BUTTON_PIN) == LOW) {
    resetAngles();  // Reset the angles when the button is pressed
    Serial.println("Button pressed: Angles reset");
    delay(500);  // Simple debounce to avoid multiple triggers
  }

  // If manual buzzer control is active, use that state
  if (manual_buzzer_override) {
    digitalWrite(BUZZER_PIN, manual_buzzer_state ? HIGH : LOW);
  } 
  else {
    // Process MPU6050 data for back posture detection
    Wire.beginTransmission(MPU6050_ADDR);
    Wire.write(ACCEL_XOUT_H);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU6050_ADDR, 6, true); // Request 6 bytes of data
    
    ax = (Wire.read() << 8) | Wire.read();
    ay = (Wire.read() << 8) | Wire.read();
    az = (Wire.read() << 8) | Wire.read();
  
    // Convert accelerometer data to 'g' (assuming the sensor is set to ±2g)
    float ax_g = ax / 16384.0;
    float ay_g = ay / 16384.0;
    float az_g = az / 16384.0;
  
    // Calculate the current roll and pitch angles
    roll = atan2(ay_g, az_g) * 180.0 / M_PI;
    pitch = atan2(-ax_g, sqrt(ay_g * ay_g + az_g * az_g)) * 180.0 / M_PI;
    
    // Debug output (optional)
    Serial.print("Roll: ");
    Serial.print(roll);
    Serial.print("\tPitch: ");
    Serial.println(pitch);
  
    // Determine if back posture alert should be active based on tilt
    bool bad_posture = (fabs(roll - initial_roll) > angle_threshold || 
                         fabs(pitch - initial_pitch) > angle_threshold);
                         
    // Control the buzzer based on posture
    digitalWrite(BUZZER_PIN, bad_posture ? HIGH : LOW);
  }
  
  // Small delay to prevent CPU hogging
  delay(100);
}


// Turn the buzzer on manually
void handleBuzzerOn() {
  manual_buzzer_override = true;
  manual_buzzer_state = true;
  server.send(200, "text/plain", "Buzzer turned ON");
  Serial.println("Manual buzzer ON");
}

// Turn the buzzer off manually
void handleBuzzerOff() {
  manual_buzzer_override = true;
  manual_buzzer_state = false;
  server.send(200, "text/plain", "Buzzer turned OFF");
  Serial.println("Manual buzzer OFF");
}
void resetAngles() {
  // Read the initial accelerometer data again to recalculate angles
  Wire.beginTransmission(MPU6050_ADDR);
  Wire.write(ACCEL_XOUT_H);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU6050_ADDR, 6, true); // Request 6 bytes of data
  
  ax = (Wire.read() << 8) | Wire.read();
  ay = (Wire.read() << 8) | Wire.read();
  az = (Wire.read() << 8) | Wire.read();
  
  // Convert accelerometer data to 'g' (assuming the sensor is set to ±2g)
  float ax_g = ax / 16384.0;
  float ay_g = ay / 16384.0;
  float az_g = az / 16384.0;

  // Recalculate the roll and pitch angles
  initial_roll = atan2(ay_g, az_g) * 180.0 / M_PI;
  initial_pitch = atan2(-ax_g, sqrt(ay_g * ay_g + az_g * az_g)) * 180.0 / M_PI;

  // Print the new initial angles to the serial monitor
  Serial.print("Angles Reset. New Initial Roll: ");
  Serial.print(initial_roll);
  Serial.print("\tNew Initial Pitch: ");
  Serial.println(initial_pitch);
}
